# Java设计模式——桥接模式

## 1.桥接模式

将抽象的部分与他实现部分解耦，使得两者都能够独立变化。

主要角色有四个：

​	1）Abstraction(抽象类)：定义抽象类的接口，通常是抽象类，其中定义一个Implementor实现类接口类型的对象并可以维护该对象，他与Implementor之间具有关联关系，既可以包含抽象业务方法，也可以包含具体业务方法。

​	2）RefindAbstraction扩充抽象类：由Abstraction扩充的接口，通常情况下不是抽象类而是具体类，实现了Abstraction中声明的抽象业务方法，由于继承了Abstraction所以可以通过调用Implementor的业务方法。

​	3）Implementor实现类接口：定义实现类的接口，不一定要与Abstraction的接口完全一致。事实上两个接口可以完全不同。一般而言Implementor接口仅提供基本操作，而Abstraction定义的接口可能做更多更复杂的操作。Implementor对基本操作做出声明，交给子类去实现，一般为接口。在Abstration中，Implementor作为一个成员，因此可以被调用，具体实现交给实现Implementor的子类ConcreteImplementor具体实现类。

​	4）ConcreteImplementor具体实现类：实现了Implementor接口的子类。

![image-20210823184231315](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210823184231315.png)

​		之前我们在抽象工厂生成的类中采用了二级工厂的模式进行了子类的组合创建了对应组合的对象，但实际上抽象工厂产生的类存在冗余的情况，如果我想要实现三种大小不同的画笔能勾勒12种颜色，采用抽象工厂模式就需要设计3*12种抽象工厂实现类，为了减少代码的重复，我们可以创建一个较好的类结构，让多个功能通过桥接的方式连接起来。比如我们需要一个多功能画笔，我们首先需要一个画笔类用来承担其他功能的载体，将我们需要的功能（Implementor）比如颜色、形状等都作为画笔的成员，颜色、形状这些功能再由根据其模板（Implementor）去实现对应的填充颜色和修改形状的功能,得到了实现了对应功能的画板如能发出红色的画板、能画出正方形的画板（具体实现类）将这些画板的模板按照不同功能组合到万能画笔（抽象类）中，再通过万能画笔的拓展笔头（扩充抽象类）来实现画笔本身的某些特点（扩展抽象类中实现的抽象类中的抽象方法），比如笔尖粗细变化等。这样画笔（抽象类）只要沾了对应的功能画板（成员接口的方法）就可以让画笔来实现对应的功能（成员接口对应的具体实现类的实现方法），再通过拓展笔头（继承了抽象类的扩展抽象类）去调节笔头自身的属性（调用扩展抽象类实现的抽象类的方法），就可以获得一个我们想要的画笔。

​		这样我们无需每个组合都去创建一个工厂去生成对应的画笔，只需要将功能都确定好，在需要的时候去更替对应的功能的具体实现类或者更替扩展抽象类并将之前的功能迁移过来即可。

​		桥接模式和适配器模式的组合，当功能的接口无法适配**功能实现类接口**，我们就需要一个适配器作为**实现类**，再用适配器调用新的功能接口。

​		桥接模式的用意是将抽象化与实现化脱耦，使得两者可以单独变化，将继承关系转换成关联关系，从而降低系统耦合度。

## 2、桥接模式的特点

1)优点

①**分离抽象接口及其实现部分**，将功能接口与具体类分离，通过功能的组合创建一个符合需求的类

②**可以取代多层继承方案，**极大地减少了子类的个数。

③**提高了系统的可扩展性**，在两个变化维度中任意扩展一个维度，不需要修改原有系统，符合开闭原则

2）缺点

①**会增加系统的理解与设计难度**，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程，需要开发者确定用户究竟需要哪些功能，一旦确定就把抽象类的成员固定，相应的抽象方法也固定了，之后需要添加功能需要另外加一个成员变量，同时需要在抽象类中定义对应的抽象方法或具体实现。不符合开闭原则

②**正确识别出系统中两个独立变化的维度并不是一件容易的事情**

3）适用场景：

①**需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系**

②**抽象部分和实现部分可以以继承的方式**独立扩展而互不影响

③一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立地进行扩展

④**不希望使用继承**或因为多层继承导致系统类的个数急剧增加的系统

