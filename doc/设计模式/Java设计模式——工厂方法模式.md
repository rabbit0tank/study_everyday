# Java设计模式——工厂方法模式

## 1.简单工厂模式

​		定义一个给工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。	

​		例如我们需要苹果，通过水果农场创建出需要的苹果。水果农场就是**工厂角色**，水果就是**抽象产品角色**，苹果就是**具体产品角色**。

## 2.工厂方法模式

​		定义一个用于创建对象的接口，但是让之内决定将哪一个类实例化，工厂方法模式让一个类的实例化延迟到其子类。

​		例如假设种*苹果和橘子*（**具体产品**）存在相同的相同的某些属性（甜度、颜色、植物纤维含量），我们需要创建苹果和橘子时，可以将这些属性提取出来作为*水果*（**抽象产品**），按理说所有的生产工厂都有一个固定模式，我们定义一个用于生产水果的工厂的*生产模板*（**抽象工厂**），为了能让给水果工厂能正常地给我们苹果，我们创建一个具体工厂来实现它的模板，根据实际的具体产品苹果对工厂进行完善，让它的模板机器能生产出一个苹果。最后再通过抽象水果工厂对象选择苹果工厂子类的，通过方法的重写，用*水果*（**抽象产品**）对象来接受由*水果工厂*（**具体工厂**）产生的具体产品苹果。由此我们得到了水果对象，但是它本身其实就是由苹果工厂生产出的苹果

​		一个点菜员（**具体工厂**）负责一个菜的菜谱（**具体产品**），我们只要告诉对应的菜的点菜员就可以获取到自己想要的菜，这样的好处在于我们不必记住我们告诉他指令（**传入参数**）之后怎么去(**传入参数之后的业务逻辑**)得到对应的菜（**具体产品**）

我们依据水果的公共特点（小类的公共特点）来确定我们需要找到的是什么类型的水果

​		一个工厂模式方法一般包括：

​		1.**Product（抽象产品）**：产品接口，抽象工厂中生产具体产品的模板，为具体产品公共部分的集合

​		2.**ConcreteProduct(具体产品)**：具体产品的公共特点整合为抽象产品，交给抽象工厂进行公共信息的填入与实例化，随后根据抽象父类转化为具体子类对象。

​		3**.Factory(抽象工厂)**：声明一个抽象方法用于生产抽象产品，具体工厂根据这个方法来创建对应相应抽象产品工厂的

​		4.**ConcreteFactory(具体工厂)**：实现抽象工厂的工厂方法，用于生产抽象产品。

## 3.工厂方法的特点：

1.优点：无需关心创建细节，甚至无需知道创建具体实体产品的名称，你只需要知道你需要知道你得到了一个名叫苹果的水果，所有的性质都是苹果的性质，但是你还是没有获取到具体的苹果，只是一个抽象的苹果，即具有苹果性质的水果；基于工厂角色和产品角色的多态设计是工厂方法模式的关键；抽象工厂、抽象产品让对象的创建可拓展，符合开闭原则。

2.缺点：一个具体产品对应一个具体工厂，增加系统复杂性，对象的创建可拓展导致了系统的抽象和理解难。

3.场景：客户无需知道他需要的对象实际是属于什么类，只调用一系列相似产品的公共属性或者方法；抽象工厂类通过其子类来指定那个对象