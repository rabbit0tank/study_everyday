# Java设计模式——装饰模式

## 1.装饰模式

```
	动态地给一个对象添加一些额外的职责。就拓展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。
```

​		对一个对象从外层进行包装，类似于毛胚房的装修，使得对象具有更多的功能。

​		在过去我们采用继承的方式来添加新的功能，但是新的功能子类之间可能存在重复的代码，而且子类之间不能重用。而装饰模式解决了过去继承带来的代码不能重用的问题且能够自由组合的一种模式。



​		主要角色有三个：

​		1)Component抽象构件：具体构件、抽象装饰类的公共父类，声明了在具体构件中实现的业务方法，客户端直接通过调用抽象构件的方法，从而让对应构件的重写的业务执行。

​		2)ConcreteComponment具体构件：抽象构件类的子类，用于定义具体的构件对象，实现抽象构件的方法

​		3)Decorator抽象装饰类：抽象构件内的子类，用于给具体构件添加职责（方法），该类只提供职责的接口，具体实现需要由具体装饰类实现。它维护一个指向抽象构建对象的引用，通过在自身的业务方法中引用抽象构建对象成员来调用具体构件的业务，通过具体装饰类将业务方法再次重写并回调抽象装饰类的方法，并添加具体装饰类的其他方法的调用，从而实现装饰的目的

​		4)ConcreteDecorator具体装饰类：抽象装饰类的子类，负责向构件添加新的职责，每一个具体装饰类都定义一些新的方法用于给父类的具体构建成员实现装饰目的

![image-20210826111635330](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210826111635330.png)

​		其原理便是通过抽象构件来将实际装饰的对象不断更替，它可以是具体装饰的目标，也可以是通过装饰类装饰过的构件进行嵌套装饰    new ConcreteDecorator(new ConcreteDecorator(new ConcreteComponent()))		

​		装饰模式正如其名是装饰类对象用的，我们拿制作礼物盒子为例，加入朋友生日我们需要一个精美的礼物盒，那我们首先要清楚组成礼物盒所有部分都是物品（抽象构件），每一个物品都有自己的功能（抽象构件的功能方法），基础是一个盒子（具体构件），装饰物(抽象装饰类)就是彩带、彩纸子类的（具体装饰类），而彩带和彩纸这类东西有具有相同的属性就是将某个物品装饰的很好看（抽象装饰构件的功能方法），由此可得彩带和彩纸需要依托于一个具体的物品（抽象构件成员对象），可以是一个盒子（具体构件），可以把彩带装饰到彩纸上（装饰构件）。因为彩带和彩纸是两种不同的物品，它们各自在装饰物品上又有自己的特色，彩带需要反复打结，而彩纸需要反复折叠（具体装饰类新增的业务方法），最终都得在装饰时处理（调用具体装饰类重写的功能方法），而装饰的顺序由则是由各个部件的位置决定，可以根据实际需求，可以从里到外进行装饰，先装好里面东西在不断往外包装（先调用父类功能方法，再调用自身具体的装饰方法）也可以从外到里面装饰，先把最外面的处理好，在不断往里面优化，最终放入对应的物品（先调用自身的具体装饰方法，再调用父类功能方法。）就像盒子必须装礼物而不是装饰一样，作为最高级的装饰父类，必须实现将物品装入的功能，因此抽象装饰类就是礼物盒子装饰的最重要的一部分，其针对的对象必须时盒子，盒子装东西的功能由盒子自己实现（具体构件的功能方法），而抽象装饰类需要必须依托盒子，然后把礼物装进盒子里(调用抽象构件对象的功能方法，一般此抽象构件都是指向具体构件)

## 2.透明装饰模式和半透明装饰模式

​		在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型。

```java
Cipher sc,cc,ac;
sc=new SimpleCipher();
cc=new ComplexCipher(sc);	
ac=new AdvancedCipher(cc); 

```

​		大多数装饰模式都是半透明(semi-transparent)的装饰模式，而不是完全透明(transparent)的。即允许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增加的业务方法

```java
Transform camaro;
camaro=new Car();
camaro.move();
Robot bumblebee=new Robot(camaro);
bumblebee.move();
bumblebee.say(); 

```

​		

## 3.装饰模式特点

1）优点:

①装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式对对象的功能采用子类间的相互调用接口方法来实现功能的拓展，相对而言不用产生较长的继承链，我们要装饰一个盒子不用一步一步把盒子的基础打好再一步一步地装饰，装饰的步骤由我们自己决定（具体装饰构件的功能方法重写决定） 

②可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。无需再通过反复继承，减少类的重复，将用于装饰的对象直接作为抽象装饰类的子类，子类之间可以反复叠加来更新其依托的成员对象，再调用对应的功能方法，最终针对抽象装饰类里的具体构件对象进行反复处理装饰。

③通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。

④具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。

2）缺点：

①使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。实例增多,类的结构变简单,导致速度减慢.

②这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。由于所有的装饰步骤必须新建一个具体装饰类对象，因此会产生很多对象，每一个对象对应装饰的一步，对象的层级结构会逐渐复杂。用包装礼物的思路讲，如果其中一个步骤搞砸了，我们需要将整个礼物包装纸（彩纸、彩带）一点一点地拆下来才知道哪里出现了莫名的凸起导致整个礼物和变得凹凸不平。

3）使用场景

①在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。 

②需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。  

③当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）。



**PS.不能动态地组合多于一个的抽象化角色和实现化角色,装饰模式最终装饰的只能是一个抽象化对象或者实现化对象.**

