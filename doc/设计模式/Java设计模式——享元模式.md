# Java设计模式——享元模式

## 1.享元模式

​		运用共享技术有效地支持大量细粒度对象的复用。将对象之间相同的成员对象存入享元池中，然后在需要的是否将对应的成员赋值，即获得享元池中的元素。

​		主要角色：

​		1）FlyWeight(抽象享元类)：接口或者抽象类，声明具体享元类公共方法，公共方法包括两种类型：

​		①内部状态方法:向外界提供享元对象自身成员对象数据的方法

​		②外部状态方法:外部状态是随环境改变而改变的、不可以共享的状态。在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。 

​		2）ConcreteFlyweight(具体享元类)：具体享元类实现抽象享元类，享元对象，存储内部状态（公共成员部分）。结合单例模式设计为每一个具体享元类提供唯一享元对象。

​		3）UnsharedConcreteFlyweight(非共享具体享元类)：不能被共享的具体享元类，直接通过实例化创建一个非共享具体享元类对象。

​		4）FlyweightFactory(享元工厂)：用于创建并管理享元对象，针对抽象享元类编程，各种类型的具体享元对象存储到一个享元池中，享元池一般设计成一个的存储**键值对**的集合，享元元素的实现类似工厂模式，但不同于工厂模式通过在使用时创建对象，享元元素一般都是生产好直接存入享元池，供其他类使用。相当于工厂模式是你需要再给你生产，每次生产的结果都是新的，都是即时生成对应的对象。而享元元素的使用是你需要一个对象，他发现没有，就生产好一个对象供你使用，之后你需要再用这个类的对象时，他还是给你之前的对象以供使用，享元工厂会把新的生产对象存入线程池，以供反复使用。因此一般享元工厂产生的对象不会进行任何改动，而工厂模式产生的对象允许反复修改。

![image-20210830141004684](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210830141004684.png)

​		类似我们生活中某些工具，如缝纫用的针，正常情况下都是在我们的工具盒子中（享元池），当然如果没有工具盒子，我们还得去买（编写工具盒子类），有了工具盒子没有针我们也得去买，为了减少出行的路程，我们一般会去那些百货商店购买物品，因为百货商店的商品（具体享元类）种类很多，而且很全面，这些商品都是有自己功能，所以我们只要把买过来的工具放到工具盒子中对应的功能区块即可（实例化具体享元类，并放置到享元工厂的享元池中），功能区块的组合便是享元池，但是我们一般要进行某个工作，比如缝纫都是需要用到工具盒子中的某些功能，或者需要它本身的某些特性，比如你需要铁就把针的铁的属性获取过来（一般也不会调用成员对象）或者需要用到它穿透布的功能，我们就需要将他的对应功能使用到我们的工作中（调用抽象享元类的方法，一般为具体享元类共同的功能方法，具体享元内具体对应的功能给实现。）如果不止一种功能，可以通过在具体享元类里面添加私有方法，通过传入参数的方式调用对应的功能方法。

​		保留相同的属性值的属性（**享元**），不同的属性存储在其他变量列表或者数据库中，到需要用的时候再把可变的属性与相同的属性值的属性组合起来。

## 2.有外部状态的享元模式

​		外部状态的成员对象都是外部环境赋予对应数值，通过对应的功能方法传入外部状态对应的对象，由抽象享元方法传递到对应的具体享元类中。具体享元类不用知道外部状态究竟是多少数值，在享元模式中具体实现类可以对外部状态的成员属性的数值进行获取与修改。外部状态是由客户端保存和维护的状态。

## 3.单纯享元模式和复合享元模式

​		单纯享元模式所有的享元元素都是可以共享的，而复合享元模式就是将一些单纯享元使用组合模式加以组合，可以形成复合享元对象，组成复合享元对象本身不能共享，它是由多个单纯享元组合而成，一起工作，其中多个单纯享元是不允许共享的 了。比如我们创建士兵，通过组合头部享元、身体享元、下肢享元作为组合享元来创建对应兵种的士兵，其中头部、身体、下肢这些享元类都不是共享的。 复合享元模式如下图所示。

![image-20210830160814173](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210830160814173.png)

## 4.享元模式的特点

​		1）优点：

​		①享元模式的优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。
​		②享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。

​		2）缺点：

​		①享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。
​		②为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。

​		３）使用环境：

​		①一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费。
​		②对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。
​		③使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。

PS.桥接模式减少的是加载类的数量，而享元模式是为了减少实际生成实例的数量

