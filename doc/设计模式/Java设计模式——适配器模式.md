# Java设计模式——适配器模式

## 1.适配器

​		类似于平常我们使用的电源适配器与充电插头，将电源插头220V的电压适配成我们电脑和手机能承受的电压，从而使得充电能正常运行。Java的适配器模式就是将一个类的接口转换成客户希望的另一个接口，适配器模式让那些接口不兼容的类可以一起工作。

​		主要角色有三个：

​		1）**Target目标抽象类**：目标对象所需要的接口，即用户所需要的接口。可以是一个抽象类或接口，也可以时具体类

​		2）**Adapter适配器类**：调用另一个接口，作为转换器将Adaptee与Target进行适配。类适配器中，它通过实现Targert接口并继承Adaptee类使得两者之间产生关系；在对象适配器中，它通过继承Target并关联一个Adaptee对象使得两者产生关系。

​		3）**Adaptee适配者**：定义一个已经存在的接口，这个接口需要适配，说是接口，实际上他一般是具体类，包含客户希望使用的业务方法，再某些情况下甚至没有适配类的源代码。


​		放在生活中以充电为例，电源插座就是适配者，我们要想做一个电源类适配器就需要再来一个插座/电源适配器(Adapter)，这个插座叠在旧的插座上，能够获取旧插座(Adaptee)的方法来获取电源，同时它也实现了我们需要充电对象（Target）的传输电的协议，适配器自己将电压转化为对应的电压，将从旧的插座中的获取到的电源通过目标充电协议给目标充电。

​		电源对象适配器就是一个拥有适配者对象的适配器，类似于移动电源。我们如果需要电源，就直接从成员中获取电源，同时由于继承它具有传输电的协议，于是它可以将电源直接给父类，通过调用父类的传输协议转化为合适的电压，然后再传给需要电源的对象。(备注：移动电源的本质其实就是具有手机电池类似的大容量电池模组，内含的电源电压和手机差不多，与手机一样需要从插座中获取电源存储到大容量电池模组中。因此移动电源就是把电的能量存储到电池模组中再实现传输电源的协议，从而实现给手机充电。)

​		对象适配器比类适配器灵活，对象适配器通过继承目标类，关联适配者，可以实现一个适配器对应多个适配者。如果通过实现对应的目标类，继承适配者，一个适配器只能是配一个适配者，而我们适配模式更多的是通过适配器来实现旧的接口来运行新的适配者类的功能方法，使得旧的接口能够被拓展，能够适应多个功能。

​		适配器模式就是借助适配器来调用新的功能类的方法，由于新的功能类和原有的接口不同，需要让适配器去实现原有接口，在原有接口实现中调用对应新功能接口。

## 2.缺省适配器模式

​		不需要实现一个接口提供所有方法时，先设计一个抽象类实现该接口，并为接口的灭个方法提供一个默认实现方法或者空方法。那么该抽象类的子类就可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口所有方法的情况，又被称为当借口适配器模式。针对于类适配器，只需要适配者的部分方法，将类适配器封装成一个抽象类，最后通过继承类适配器来获得适配者的方法。

主要角色有三个。

​		ServiceInterface(适配者接口)：声明了适配者具有的方法。

​		AbstractServiceClass(缺省适配器类)：实现适配者接口的抽象类，实现的结果为默认方法，因此可以为空。

​		ConcreteServiceClass(具体事务类)：继承缺省适配器的子类，直接实现适配者接口我们需要实现的部分，没有实现的部分由缺省适配器类提供默认方法。


## 3.双向适配器模式

同时有目标类对象和适配者类对象的适配器，同时实现两者接口以达到使用适配器就可以实现两者对象的功能。能够自主转化两者之间的关系，即调用适配器实现的目标对象的方法，就可以将适配者的属性拿过来给目标对象用，而调用适配器实现的适配者对象的方法，就可以将目标对象的属性方法拿过来给适配者对象使用。


## 4.适配者模式的特点。

1）优点：

①将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构,无需改变目标类和适配者类，简单的讲你想要给手机充电就不需要提供一个能接受220V电压的手机，也不需要能产生正常手机电压的插座。

②**增加了类的透明性和复用性**，提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用，你要想给电脑充电还是给手机充电，只要充电协议相同（目标类的接口相同）或者让适配器去实现另一个产品的充电协议（实现目标接口方法），代码可复用

③**灵活性和扩展性非常好**

④**类适配器模式：**置换一些适配者的方法很方便

⑤**对象适配器模式：**可以把多个不同的适配者适配到同一个目标，还可以适配一个适配者的子类

2）缺点：

①**类适配器模式：**(1)**一次最多只能适配一个适配者类，不能同时适配多个适配者；**(2) **适配者类不能为最终类；**(3) **目标抽象类只能为接口，不能为类**

②**对象适配器模式：**在适配器中置换适配者类的某些方法比较麻烦，同样是充电的例子，要是如果哪天电的使用或者存储方式革新那么就需要更改移动电源里面使用与存储电的所有方法，否则无法正常让产品接受适合产品的电压

3）使用场景：

①系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码，适配者缺少对应实现类。

②创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作，相当于一个转换器，以较少的成本将多个仪器组合起来实现目标功能。

